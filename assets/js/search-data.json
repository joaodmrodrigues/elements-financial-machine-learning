{
  
    
        "post0": {
            "title": "Trading with the Kelly criterion",
            "content": "Motivation . Forecasting the direction of the next price movement is only part of the problem of trading. A proper capital allocation to that forecast its equally significant, althought is importance is often underestimated. Here, I&#39;m considering the problem of capital allocation on a single strategy, and not that of optimal portfolio allocation when we are investing in more than one instrument, like the framework of Modern Portfolio Theory. . A remarkable insight into this subject has been given by (Kelly, 1956). A good introduction to the subject can be found in Wikipedia. Thorpe also has a very interesting technical review (Thorp, 2008) and (Cover, 1999), like Kelly in its original paper, describes the interesting connections with information theory. . Kelly addresses the problem of optimal capital allocation under a statistically favourable (in expectation) betting opportunity. Two important conclusions from his work are: . Even in the presence of a favourable bet, over-allocation of capital will lead to ruin in the long run with probability 1. | Knowing the probability of the possible outcomes allows us to optimally size our bet (or position) in the sense of maximizing the expected growth rate of our portfolio. . Note: While point 1 may seem counterintuitive at first, think that if your portfolio falls 50%, it has to grow 100% to come back to its initial value. | Mathematical formulation . Let&#39;s consider the following formulation of the Kelly criterion: . Let&#39;s define $R_t$ as the random variable describing the returns of our strategy (or returns of a price time-series) at time $t$. The portfolio value at time $t+1$ is then the random variable $P_{t+1}$ given by . $$ P_{t+1} = p_t (1+ f R_t) $$ . with $p_t$ the portfolio value at $t$ and $f$ the respective fraction allocated to the strategy. Note that, $f$ can be negative, meaning that we are going short on the strategy (or instrument). If we have leverage available, $ vert f vert$ can also be greater than 1. The portfolio value $P_{t+1}$ can also be written as . $$ P_{t+1} = e^{ Lambda}, $$ . assuming, without loss of generality, $p_t = 1$. Here, $ Lambda = mathrm{log}(1 + f R_t)$ is the random variable describing the portfolio growth rate. The Kelly criterion gives the optimal value of $f$ in the sense of maximizing the expected value of $ Lambda$. If $R_t$ follows a normal distribution $ mathcal{N} ( mu_r, sigma_r)$, (Thorp, 2008) has shown that the Kelly-optimal value of $f$ is given by . $$ f = frac{ mu_r}{ sigma_r^2}. $$ . Note: In order to study the long-term portfolio growth, we are actually interested in the random variable . $$ P_{t+1} = p_1 (1+ f R_1)(1+ f R_2) ... (1+ f R_t). $$ . However, we are assuming that the $R_1$, $R_2$, ..., are independent. In this case, we can simplify the problem into the formulation above. . Monte-Carlo simulation . In order to appreciate the power of the Kelly criterion, we are going to conduct Monte-Carlo simulations, where at each time step the returns of our price time series are going to be drawn from a normal distribution $ mathcal{N} ( mu_r, sigma_r)$. However, in order to simulate a more realistic and dynamical scenario, $ mu_r$ and $ sigma_r$ will themselves be modelled as stochastic processes as well. In particular, I am going to model $ mu_{r,t}$ via an Ornstein-Ulhenbeck process, and $ sigma_{r,t}$ via a geometric Ornstein-Ulhenbeck process. The latter, for instance, allows the time-series to become heteroskedastic. . The Ornstein-Ulhenbeck process is defined as: . $$ dY_t = - frac{(Y_t - mu)}{ tau}dt + sigma sqrt{ frac{2}{ tau}} dW_t, $$ . with $ mu$ and $ sigma$ the process mean and standard deviation, respectively, and $W_t$ is Brownian motion. The geometric version is defined as . $$ dY_t = - frac{(Y_t - mu)}{ tau}dt + sigma Y_t dW_t. $$ . We can numerically integrate the stochastic differential equations above using the Euler-Maruyama method, implemented in the functions below: . Note: The entire code shown in this article has been written for the purpose of clarity rather than efficiency . import numpy as np def Ornstein_Ulhenbeck(T, dt, mu, sigma, tau, Y0): # Initializations Y = list() t = np.arange(0, T, dt) Y.append(Y0) # Parameters N = len(t) sigma_term = sigma*np.sqrt(2.0/tau)*np.sqrt(dt) normal_draws = np.random.normal(loc=0.0, scale=1.0, size=N) # Integration for i in range(1, N): Y.append(Y[-1] - dt*(Y[-1]-mu)/tau + sigma_term*normal_draws[i]) return np.array(Y) def geometric_Ornstein_Ulhenbeck(T, dt, mu, sigma, tau, Y0): # Initializations Y = list() t = np.arange(0, T, dt) Y.append(Y0) # Parameters N = len(t) sigma_term = sigma*np.sqrt(dt) normal_draws = np.random.normal(loc=0.0, scale=1.0, size=N) # Integration for i in range(1, N): Y.append(Y[-1] - dt*(Y[-1]-mu)/tau + sigma_term*Y[-1]*normal_draws[i]) return np.array(Y) . . Let&#39;s simulate 1000 price bars: . Stochastic path for the mean of the returns - $ mu_{r,t}$ . T = 1000 dt = 1 mu = 0 sigma = 0.002 tau = 1 path_mean = Ornstein_Ulhenbeck(T=T, dt=dt, mu=mu, sigma=sigma, tau=tau, Y0=mu) . And plotting the results: . import matplotlib.pyplot as plt fig, axes = plt.subplots(1, 1, figsize=(14, 4)) axes.plot(path_mean, &#39;-&#39;, color=(0.8,0.5,0.5,1.0)) axes.set_xlabel(&quot;Bar&quot;) _=axes.set_ylabel(&quot;Path for returns mean&quot;) . . Stochastic path for the volatility of the returns - $ sigma_{r,t}$ . T = 1000 dt = 1 mu = 0.02 sigma = 0.01 tau = 10 path_std = geometric_Ornstein_Ulhenbeck(T=T, dt=dt, mu=mu, sigma=sigma, tau=tau, Y0=mu) . Plotting the results: . import matplotlib.pyplot as plt fig, axes = plt.subplots(1, 1, figsize=(14, 4)) axes.plot(path_std, &#39;-&#39;, color=(0.8,0.5,0.5,1.0)) axes.set_xlabel(&quot;Bar&quot;) _=axes.set_ylabel(&quot;Path for returns volatility&quot;) . . Price path . From the paths generated above, we can now draw the returns $R_t sim mathcal{N} ( mu_{r,t}, sigma_{r,t})$ and the resulting price series $p_t = p_1 displaystyle prod_{t&#39;= 1}^t (1+r_{t&#39;})$: . path_returns = np.random.normal(loc=path_mean, scale=path_std) path_price = 100*np.cumprod(1+path_returns) . fig, axes = plt.subplots(1, 2, figsize=(14, 4)) axes[0].plot(path_returns, &#39;-&#39;, color=(0.8,0.5,0.5,1.0)) axes[0].set_xlabel(&quot;Bar&quot;) axes[0].set_ylabel(&quot;Realized returns&quot;) axes[0].set_title(&quot;Returns&quot;) axes[1].plot(path_price, &#39;-&#39;, color=(0.5,0.5,0.8,1.0)) axes[1].set_xlabel(&quot;Bar&quot;) axes[1].set_ylabel(&quot;Realized price&quot;) axes[1].set_title(&quot;Price&quot;) plt.show() . . The parameters above have been chosen such that the hit ratio - fraction of bars where the expected return $ mu_{r,t}$ is of the same sign as the realized return $r_t$ - varies approximately between 0.5 and 0.6. For this particular realization: . hit_ratio = np.sum(np.sign(path_returns*path_mean)&gt;0)/len(path_returns) print(hit_ratio) . 0.516 . Allocation strategies . Let&#39;s create a function that calculates the portfolio growth. It takes as parameters the initial portfolio value, the fraction of the portfolio invested at every bar (negative for short positions and positive for long positions), and the realized price returns . I am also assuming that we are effectively bankrupted it at any point our porfolio drops below 1 percent of its initial value: . def calculate_portfolio_growth(portfolio_initial, fractions, price_returns): N = len(fractions) strategy_returns = fractions*price_returns portfolio_growth = portfolio_initial*np.cumprod(1+strategy_returns) if True in [value&lt;=1e-2*portfolio_initial for value in portfolio_growth]: bust_ind = np.min(np.where(portfolio_growth&lt;1e-2*portfolio_initial)[0]) portfolio_growth[bust_ind:] = 0 return portfolio_growth . We are going to assume maximum available leverage of 10 and three different allocation strategies: . Full leverage | Half leverage | Optimal Kelly allocation (limited to a maximum of 10x leverage) | portfolio_initial = 1 leverage = 10 ##### Strategy 1 - full leverage fractions1 = leverage * np.sign(path_mean) portfolio1 = calculate_portfolio_growth(portfolio_initial=portfolio_initial, fractions=fractions1, price_returns=path_returns) ##### Strategy 2 - half leverage fractions2 = 0.5*leverage * np.sign(path_mean) portfolio2 = calculate_portfolio_growth(portfolio_initial=portfolio_initial, fractions=fractions2, price_returns=path_returns) ##### Strategy 3 - Kelly fractions3 = path_mean/path_std**2 fractions3[fractions3&gt;leverage] = leverage fractions3[fractions3&lt;-leverage] = -leverage portfolio3 = calculate_portfolio_growth(portfolio_initial=portfolio_initial, fractions=fractions3, price_returns=path_returns) . Let&#39;s now plot the performance of the different allocation strategies: . fig, axes = plt.subplots(1, 1, figsize=(7, 5)) axes.plot(portfolio1, &#39;-&#39;, label=&quot;Full leverage&quot;, color=(0.8,0.5,0.5,1.0)) axes.plot(portfolio2, &#39;-&#39;, label=&quot;Half leverage&quot;, color=(0.5,0.5,0.8,1.0)) axes.plot(portfolio3, &#39;-&#39;, label=&quot;Kelly optimal&quot;, color=(0.5,0.7,0.7,1.0)) axes.legend() axes.set_xlabel(&quot;Bar&quot;) axes.set_ylabel(&quot;Portfolio value&quot;) axes.set_yscale(&quot;log&quot;) . . As stated before, which we can now empirically corroborate, one of the key insights of the Kelly criterion is that, even in the presence of a favorable betting (or trading) opportunity, overallocation will eventually lead to ruin. . In the realization above, the full leverage allocation does lead to ruin. The half leverage strategy has a positive return but underperforms the optimal Kelly allocation. . We can calculate the average absolute leverage in the Kelly allocation: . print(np.round(np.mean(np.abs(fractions3)), 2)) . 5.09 . Thus, despite the similar used leverage (on average), the Kelly strategy outperforms the constant 5x leverage strategy. . A better way to conduct this analysis is through the Sharp ratio, which can be shown to be maximized (in expectation) by the Kelly-optimal allocation. . def calculate_sharp_ratio(portfolio): N = len(portfolio) if True in [value==0 for value in portfolio]: bust_ind = np.min(np.where(portfolio==0)[0]) portfolio = portfolio[:bust_ind] returns = (portfolio[1:]-portfolio[0:-1])/portfolio[0:-1] sharp_ratio = np.sqrt(252)*np.mean(returns)/np.std(returns) return sharp_ratio . In the above, we are associating each bar to a trading day, and annualizing the Sharp ratio. The results: . print(&quot;Sharp ratio, full leverage =&quot;, np.round(calculate_sharp_ratio(portfolio1),2)) print(&quot;Sharp ratio, half leverage =&quot;, np.round(calculate_sharp_ratio(portfolio2),2)) print(&quot;Sharp ratio, Kelly optimal =&quot;, np.round(calculate_sharp_ratio(portfolio3),2)) . . Sharp ratio, full leverage = -0.84 Sharp ratio, half leverage = 1.02 Sharp ratio, Kelly optimal = 1.67 . Note that, an overall multiplicative factor in the used leverage does not change the Sharp ratio. The reason why the Sharp ratio may be different between the full- and the half-leverage strategies is because of the possibility of going bankrupt. . Ensemble statistics . While the results above corroborate our expectations about the Kelly allocation, their statistical significance is somewhat meaningless, because we have considered a single realization, albeit a long one with a total of 1000. . I am going to perform many realizations (200) of the experiment above and check the performance statistics. . Note: The processes simulated here are essentially ergodic, meaning that $m$ realizations of $N$ bars each, is equivalent to a single realization of $mN$ bars, in terms of their statistical properties. For the sake of simplicity, I&#39;m going to choose the former. . n_runs = 200 strategy1 = list() strategy2 = list() strategy3 = list() for i in range(0, n_runs): # Price path path_mean = Ornstein_Ulhenbeck(T=1000, dt=1, mu=0, sigma=0.002, tau=1, Y0=0) path_std = geometric_Ornstein_Ulhenbeck(T=1000, dt=1, mu=0.02, sigma=0.01, tau=10, Y0=0.02) path_returns = np.random.normal(loc=path_mean, scale=path_std) path_price = 100*np.cumprod(1+path_returns) # Full leverage fractions1 = leverage * np.sign(path_mean) portfolio1 = calculate_portfolio_growth(portfolio_initial=portfolio_initial, fractions=fractions1, price_returns=path_returns) strategy1.append(calculate_sharp_ratio(portfolio1)) # Half leverage fractions2 = 0.5 * leverage * np.sign(path_mean) portfolio2 = calculate_portfolio_growth(portfolio_initial=portfolio_initial, fractions=fractions2, price_returns=path_returns) strategy2.append(calculate_sharp_ratio(portfolio2)) # Kelly fractions3 = path_mean/path_std**2 fractions3[fractions3&gt;leverage] = leverage fractions3[fractions3&lt;-leverage] = -leverage portfolio3 = calculate_portfolio_growth(portfolio_initial=portfolio_initial, fractions=fractions3, price_returns=path_returns) strategy3.append(calculate_sharp_ratio(portfolio3)) sharp_ratio = np.array([strategy1, strategy2, strategy3]).T strategy_labels = [&quot;Full leverage&quot;, &quot;Half leverage&quot;, &quot;Kelly optimal&quot;] . . And now plotting the results: . fig, axes = plt.subplots(1, 1, figsize=(6, 4)) axes.boxplot(sharp_ratio) axes.set_xticklabels(strategy_labels, rotation=0) axes.set_ylabel(&quot;Sharp ratio&quot;) plt.tight_layout() plt.show() print(&quot;Mean Sharp ratio, full leverage =&quot;, np.round(np.mean(sharp_ratio[:,0]),2)) print(&quot;Mean Sharp ratio, half leverage =&quot;, np.round(np.mean(sharp_ratio[:,1]),2)) print(&quot;Mean Sharp ratio, Kelly optimal =&quot;, np.round(np.mean(sharp_ratio[:,2]),2)) . . Mean Sharp ratio, full leverage = 1.3 Mean Sharp ratio, half leverage = 1.75 Mean Sharp ratio, Kelly optimal = 2.16 . Now we have statistically significant results demonstrating the outperformance of the Kelly allocation strategy. The Sharp ratio of the full-leverage strategy is highly left-skewed, due to the many times the strategy goes bankrupt. . Note: Quantitatively, the results shown here are strongly dependent on the parameters chosen in the Monte-Carlo simulation. One may even wonder if I&#39;m not somehow overfitting these parameters in order to arrive at the expected result. However, running the experiment for different sets of parameters yields that the Kelly allocation is systematically the one that shows better performance. . Final notes . I would like to end this article with a few notes: . I&#39;m applying the Kelly criterion in a slightly different way than usual. We typically consider the statistics of the returns of a given strategy, or instrument, and then calculate the optimal allocation fraction, which does not vary from one bar to the other. Then the task is to continuously rebalance the portfolio as to maintain that constant allocation fraction. Here, I&#39;m assuming that I am in the presence of a fully probabilistic pricing model which, at each bar, outputs the full probability distribution of the next price return. Given the assumption of independence between these distributions, I&#39;m conjecturing, but not proving, that by calculating the optimal Kelly fraction at each bar I&#39;m still maximizing the long-run expected growth rate of my portfolio, in expectation. | I constructed the simulations above assuming the returns to be normally distributed. While this is not a terrible assumption, it may not be a good one depending on the situation. The advantage of normally-distributed returns is the close-form solution for the optimal Kelly fraction. For a generic distribution, however, we can perform Monte-Carlo simulations to infer the optimal Kelly fraction. | By construction, in the controlled experiment described here, I know exactly the probability distribution of returns. In a real application, while we can develop full probabilistic models in complete analogy with the ideas described here, one must consider the uncertainty about the model itself. This may mean reducing, for instance, using a fraction of the optimal Kelly fraction to reduce the risk of model uncertainty. | References: . Kelly, J. L. (1956). A new interpretation of information rate. The Bell System Technical Journal, 35(4), 917–926. https://doi.org/10.1002/j.1538-7305.1956.tb03809.x | Thorp, E. O. (2008). The Kelly criterion in blackjack sports betting, and the stock market. In Handbook of asset and liability management (pp. 385–428). Elsevier. | Cover, T. M. (1999). Elements of information theory. John Wiley &amp; Sons. | .",
            "url": "https://joaodmrodrigues.github.io/elements-financial-machine-learning/kelly%20criterion/monte%20carlo/2021/02/07/kelly_criterion_in_trading.html",
            "relUrl": "/kelly%20criterion/monte%20carlo/2021/02/07/kelly_criterion_in_trading.html",
            "date": " • Feb 7, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Mutual information for feature selection",
            "content": "Motivation . In this article, I will explore information-theoretic quantities (mutual information) to perform feature selection for models on continuous variables, like a sequence of price returns, for instance. Mutual information offers many advantages, including: . Model-independent feature selection: Many feature selection techniques are inherent to a particular class of models. For instance, boruta, gini, or mean impurity decrease use tree-based models to rank the importance among a set of features. While there is an obvious value in selecting features whose predictive power is better leveraged by a particular class of models, this approach may lead to the drop of informative features if the end model is not of the same class as that used for feature selection. In this context, mutual information offers a complete model-agnostic approach to feature selection. . | Full distribution feature selection: If we are trying to model a continuous variable, most feature selection techniques end up selecting features that do better in predicting the mean of the target variable. If we are trying to forecast the return of a given price series, for instance, it is as important to predict its mean as it is to predict is uncertainty (volatility), which will allow a better sized allocation to that particular strategy or forecast. This means that we often may benefit from selecting features that carry information about different aspects of the distribution of our target, and not only its mean. Mutual information does exactly that. Even if we are working with classification models, which output buy and sell signals according to some rules, it is extremely important to have a way to model the confidence of these signals. For instance, (De Prado, 2018) describes using meta-labeling and the training of a surrogate model to predict the confidence on the buy and sell signals derived from the principal model. The best features for this surrogate model may be different than those of the first model. . | Two different kinds of relationships . Let&#39;s conduct a controlled experiment using two different scenarios: . Variable $X$ (cause) partially determines the mean of variable $Y$ (effect) | Variable $X$ (cause) partially determines the scale (standard deviation) of variable $Y$ (effect) | For the sake of simplicity, let&#39;s restrict ourselves to normal distributions here. . Let&#39;s define a function that generates these samples: . Note: The entire code shown in this article has been written for the purpose of clarity rather than efficiency . import numpy as np def normalize(sample): return (sample-np.mean(sample))/np.std(sample) def generate_samples(N, dependence_coef, which_param): ### Cause samples_cause = np.random.normal(loc=0.0, scale=1.0, size=N) ### Effect inherent_noise = np.random.normal(loc=0.5, scale=1.0, size=N) param = normalize((1-dependence_coef)*inherent_noise + dependence_coef*samples_cause) samples_effect = list() for i in range(0, N): if which_param == 1: # relationship on the mean mean = param[i] scale = 1.0 if which_param == 2: # relationship on the scale mean = np.random.normal(loc=np.random.normal(loc=0, scale=1.0)) scale = np.exp(param[i]) [samples_effect.append(np.random.normal(loc=mean, scale=scale))] return [normalize(samples_cause), normalize(samples_effect)] . . Note that we are allowing a varying level of &quot;causation&quot; between $X$ and $Y$, determined by dependence_coef which varies between 0 (no relation) and 1 (strong relation). Also, strong relation does not imply a perfect correlation between the variables. We are constantly drawing points from univariate normal distributions, where the parameters of the distribution of $Y$ - either mean or scale - depend on the value of $X$, at each observation. This ensures a more complex and non-trivial stochastic relation between the two random variables. . Let&#39;s generate these samples, assuming a dependence coefficient of 0.5: . N = 10000 dependence_coef = 0.5 # Relationship on the mean (cause_mean, effect_mean) = generate_samples(N=N, dependence_coef=dependence_coef, which_param=1) # Relationship on the scale (cause_scale, effect_scale) = generate_samples(N=N, dependence_coef=dependence_coef, which_param=2) . . And now let&#39;s plot the samples: . import matplotlib.pyplot as plt fig, axes = plt.subplots(1, 2, figsize=(10, 4), constrained_layout=True) axes[0].plot(cause_mean, effect_mean, &#39;.&#39;, color=(0.8,0.5,0.5,0.2)) axes[0].set_xlabel(&quot;Cause - X&quot;) axes[0].set_ylabel(&quot;Effect - Y&quot;) axes[0].set_title(&quot;Relation on the mean&quot;) axes[1].plot(cause_scale, effect_scale, &#39;.&#39;, color=(0.8,0.5,0.5,0.2)) axes[1].set_xlabel(&quot;Cause - X&quot;) axes[1].set_ylabel(&quot;Effect - Y&quot;) axes[1].set_title(&quot;Relation on the scale&quot;) _=plt.suptitle(&quot;Dependence coefficient = &quot;+str(dependence_coef)) . . As visible from above, on the left-hand side, $X$ is a good feature to use in predicting the mean of $Y$, but completely unrelated to its variance, which is completely stochastic by construction. On the other hand, on the right-hand side, $X$ is completely unrelated to the mean of $Y$, but it&#39;s moderately related to its scale. . Let&#39;s check other dependence coefficients: . Note: The way I constructed the &quot;Relation on the mean&quot; above results in an essentially linear relationship between $X$ and $Y$, which could be quantified by their respective covariance. However, covariance and correlation fail when the relationship between the mean of $X$ and $Y$ is nonlinear, whereas mutual information does not. The &quot;Relation on the scale&quot; construction, however, goes beyond both linear and non-linear relationships between the means of $X$ and $Y$. Despite that, and as I will demonstrate now, mutual information remains able to quantify the strength of this dependence. . Entropy, Joint Entropy and Mutual Information . I&#39;m going to quickly review the definition of entropy, joint entropy, and mutual information. A more detailed, yet simple, introduction to the subject can be found on Wikipedia, for instance. For a more complete description, (Cover, 1999) is a great reference. . For a discrete random variable $X$, we can define the Shannon entropy as . $$S(X) = - displaystyle sum_{i=1}^N p(x_i) mathrm{log}_2 [ p(x_i) ], $$ . and the joint entropy of $X$ and $Y$ as . $$S(X,Y) = - displaystyle sum_{i=1}^{N_x} displaystyle sum_{j=1}^{N_y} p(x_i, y_j) mathrm{log}_2 [ p(x_i, y_j) ].$$ . Note that, if $X$ and $Y$ are independent, $S(X,Y) = S(X) + S(Y)$. The mutual information can then be defined as . $$I(X,Y) = S(X) + S(Y) - S(X,Y),$$ . thus measuring the &quot;amount&quot; of information that is shared between $X$ and $Y$. As such, if $X$ and $Y$ are independent, $I(X,Y)=0$. An equivalent definition of mutual information can be written in terms of the conditional entropy: . $$I(X,Y) = S(X) - S(X|Y) = S(Y) - S(Y|X).$$ . We can then understand the mutual information as the information that we get about $X$ by knowing only $Y$, or vice versa. . Sample estimation . While the theoretical definitions are simple and straightforward, robustly estimating these quantities from sample data is often tricky, especially when dealing with continuous random variables. Given that we are using synthetic data here, we can produce as large samples as we want, getting good statistical convergence if so desired. We thus take the simplest approach possible of histogramming the observations and applying the above definitions directly. . Let&#39;s define some functions: . def calculate_entropy(X): # 1) Histograms the samples nbins = int(len(X)**(1/3)) p = np.histogram(X, bins=nbins, density=False)[0] p = p/np.sum(p)+1e-6 # 2) Calculates the entropy entropy = -np.sum(p*np.log2(p)) return entropy def calculate_joint_entropy(X, Y): # 1) Histograms the samples nbins = int(len(X)**(1/3)) p = np.histogram2d(X, Y, bins=nbins, density=False)[0] p = p/np.sum(p)+1e-6 # 2) Calculates the entropy entropy = -np.sum(p*np.log2(p)) return entropy def calculate_mutual_information(X, Y): S_X = calculate_entropy(X) S_Y = calculate_entropy(Y) S_XY = calculate_joint_entropy(X, Y) I = S_X+S_Y-S_XY return I . . Dealing with discretization scaling . From the point of view of estimating entropy and joint entropy, the discretization procedure above introduces a scaling that needs to be controlled for. . To deal with this issue, besides estimating the mutual information for the original sample $(x_i, y_i)$ - $I_{ mathrm{sample}}$ - we are going to estimate the mutual information on a number of datasets where the observations of one of the original variables, say $Y$, are randomly permutated - $I_{ mathrm{perm}}^j$. We can then defined the mutual information score . $$s_I = frac{I_{ mathrm{sample}} - mathrm{mean}(I_{ mathrm{perm}}^j)}{ mathrm{sd}(I_{ mathrm{perm}}^j)}.$$ . By doing this normalization, we are arriving at a quantity that is insensitive to scaling issues arising from the discretization of $X$ and $Y$. In essence, $s_I$ measures the confidence, in terms of the number of standard deviations, that the relation between $X$ and $Y$ is not random. . Some code: . def calculate_mutual_information_score(X, Y, n_perm): # Mutual information on original samples I = calculate_mutual_information(X=X, Y=Y) # Mutual information on randomly shuffled data I_perm = list() ind = np.arange(len(Y)) for i in range(0, n_perm): np.random.shuffle(ind) Y_shuffled = Y[ind] I_perm.append(calculate_mutual_information(X=X, Y=Y_shuffled)) # Calculates the mutual information score mi_score = (I-np.mean(I_perm))/np.std(I_perm) return mi_score . . Let&#39;s now conduct some estimations of the mutual information score. . Let&#39;s begin with a small dependence between $X$ and $Y$ (here, $X$ related with the mean of $Y$): . (cause, effect) = generate_samples(N=100000, dependence_coef=0.05, which_param=1) n_perm = 100 mi_score = calculate_mutual_information_score(X=cause, Y=effect, n_perm=n_perm) print(np.round(mi_score,1)) . . 0.9 . and a slighly stronger relation: . (cause, effect) = generate_samples(N=100000, dependence_coef=0.20, which_param=1) n_perm = 100 mi_score = calculate_mutual_information_score(X=cause, Y=effect, n_perm=n_perm) print(np.round(mi_score,1)) . . 67.9 . Let&#39;s do a more systematic experiment, by slowly increasing the dependence coefficient from 0 to 1, and looking at the mutual information score for the 2 cases we have been considering - mean and scale relation: . dependence_coefs = np.linspace(0, 1, 20) mi_scores_mean = list() mi_scores_scale = list() for coef in dependence_coefs: ### On mean samples = generate_samples(N=100000, dependence_coef=coef, which_param=1) samples_cause = normalize(samples[0]) samples_effect = normalize(samples[1]) mi_scores_mean.append(calculate_mutual_information_score(X=samples_cause, Y=samples_effect, n_perm=50)) ### On scale samples = generate_samples(N=100000, dependence_coef=coef, which_param=2) samples_cause = normalize(samples[0]) samples_effect = normalize(samples[1]) mi_scores_scale.append(calculate_mutual_information_score(X=samples_cause, Y=samples_effect, n_perm=50)) . . And now plotting the results: . fig, axes = plt.subplots(1, 2, figsize=(10, 3)) axes[0].plot(dependence_coefs, mi_scores_mean, &#39;-&#39;, color=(0.8,0.5,0.5,1.0)) axes[0].set_xlabel(&quot;Dependence coeficient&quot;) axes[0].set_ylabel(&quot;Mutual information score&quot;) axes[0].set_title(&quot;Relation on the mean&quot;) axes[1].plot(dependence_coefs, mi_scores_scale, &#39;-&#39;, color=(0.8,0.5,0.5,1.0)) axes[1].set_xlabel(&quot;Dependence coeficient&quot;) axes[1].set_ylabel(&quot;Mutual information score&quot;) axes[1].set_title(&quot;Relation on the scale&quot;) plt.show() . . We correctly infer the increasing strength of the relationship between $X$ and $Y$. Note that, we are arriving at such large values of the mutual information score (or equivalently, such high confidence about the non-randomness of the relationship) because of the large number of points in our samples (100000). If we re-run the experiment with 10000 points we obtain: . Dealing with sample fluctuations . In any statistical estimation problem, we are subject to the problem of sample fluctuations. Even if our data-generating process is stationary, which is the case here, different samples will lead to different mutual information scores. . The problem is more severe if the data generating process is not stationary, which is often the case in financial time series. In this case, regime or structural shifts can change the relation between variables over time. The most we are left to do is to investigate the non-uniformity of our sample using empirical techniques, like resampling, and analyze inter-sample variations. . While bootstrap and bagging, for instance, would be appropriate for the experiment we are conducting, is not appropriate in financial time series, because it does not maintain the time ordering of the observations. The premise here is that while regime shifts may occur, there is some level of persistence of a given regime. . With this in mind, we are going to consider sequential resampling: . def calculate_resample_inds(N, n_groups): inds = np.arange(N) resample_inds = np.reshape(inds[0:n_groups*int(np.floor(N/n_groups))], (-1, n_groups)) return resample_inds . . And let&#39;s generate the samples: . n_groups = 10 dependence_coefs = np.linspace(0, 1, 20) mi_scores_mean = list() mi_scores_scale = list() # Resampling indices inds = calculate_resample_inds(N=100000, n_groups=n_groups) for coef in dependence_coefs: ### On mean # Full sample samples = generate_samples(N=100000, dependence_coef=coef, which_param=1) samples_cause = normalize(samples[0]) samples_effect = normalize(samples[1]) # Resampling vals = [calculate_mutual_information_score(X=samples_cause[inds[:,i]], Y=samples_effect[inds[:,i]], n_perm=50) for i in range(0, n_groups)] mi_scores_mean.append(vals) ### On scale # Full sample samples = generate_samples(N=100000, dependence_coef=coef, which_param=2) samples_cause = normalize(samples[0]) samples_effect = normalize(samples[1]) # Resampling vals = [calculate_mutual_information_score(X=samples_cause[inds[:,i]], Y=samples_effect[inds[:,i]], n_perm=50) for i in range(0, n_groups)] mi_scores_scale.append(vals) mi_scores_mean = np.array(mi_scores_mean) mi_scores_scale = np.array(mi_scores_scale) . . And now plotting the results: . fig, axes = plt.subplots(1, 2, figsize=(12, 4)) axes[0].boxplot(mi_scores_mean.T) axes[0].set_xticklabels(np.round(dependence_coefs,2), rotation=90) axes[0].set_xlabel(&quot;Dependence coeficient&quot;) axes[0].set_ylabel(&quot;Mutual information score&quot;) axes[0].set_title(&quot;Relation on the mean&quot;) axes[1].boxplot(mi_scores_scale.T) axes[1].set_xticklabels(np.round(dependence_coefs,2), rotation=90) axes[1].set_xlabel(&quot;Dependence coeficient&quot;) axes[1].set_ylabel(&quot;Mutual information score&quot;) axes[1].set_title(&quot;Relation on the scale&quot;) plt.show() . . This resampling partially quantifies sample fluctuations and inhomogeneities. However, while in this conducted experiment we can generate samples of arbitrary size, in real datasets we are limited by the possible small number of available observations. In this case, excessive resampling, especially sequential resampling like we&#39;re doing here may lead to completely useless information. . Conclusions . The idea behind this exposition was to demonstrate the strengths of mutual-information based feature selection. One big advantage is the fact we can infer relationships that are not captured by other feature selection techniques. In the context of trading, it is tremendously important to be able to predict not only the direction of the next price movement but also the volatility or uncertainty in this forecast. This can be done, for example, by developing full probabilistic regression models or, in the context of classifications models, using the meta-labeling technique, as described in (De Prado, 2018). Mutual information-based feature selection can then be used to construct these models. . References: . De Prado, M. L. (2018). Advances in financial machine learning. John Wiley &amp; Sons. | Cover, T. M. (1999). Elements of information theory. John Wiley &amp; Sons. | .",
            "url": "https://joaodmrodrigues.github.io/elements-financial-machine-learning/information%20theory/mutual%20information/feature%20selection/feature%20importance/2021/02/06/mutal_information_and_feature_selection.html",
            "relUrl": "/information%20theory/mutual%20information/feature%20selection/feature%20importance/2021/02/06/mutal_information_and_feature_selection.html",
            "date": " • Feb 6, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "I’m a data scientist and systematic trader on a personal account. . Brief resume: . 2021 - present: Data Scientist @ Argus Media, development of forecast models for commodity markets; . | 2019 - 2020: Research Associate @ Imperial College London, machine learning applications in physics; . | 2014 - 2018: PhD in Physics @ University of Lisbon, machine learning description of turbulence; . | . For more information check the links in the bottom of this page. .",
          "url": "https://joaodmrodrigues.github.io/elements-financial-machine-learning/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
      ,"page9": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://joaodmrodrigues.github.io/elements-financial-machine-learning/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

  
  

}