{
  
    
        "post0": {
            "title": "Optimal feature clustering - Part II",
            "content": "Introduction . In Part I I described a general framework for optimal clustering based on information-theoretic arguments. The analysis conducted there was completely generic to any probabilistic clustering algorithm. . The purpose of this series of articles, however, is to describe optimal clustering of features. To do so, we need to be able to effectively calculate the distance between a pair of features, say $X$ and $Y$. This will be the subject of Part II. . Distance metrics for feature comparison . Based on (de Prado, 2020), let me briefly introduce three different metrics: . 1. Correlation distance (two-sided): $$ d_ rho (X, Y) = sqrt{(1- rho(X,Y))/2} $$ . Here, $ rho(X,Y)$ is the correlation coefficient between $X$ and $Y$. This definition has the property that, if $X$ and $Y$ are perfectly anti-correlated the distance between them is maximal. On the other hand, if $ rho(X,Y) = 1 implies d_ rho = 0$. . 2. Correlation distance (one-sided): $$ d_{ vert rho vert} = sqrt{1 - vert rho(X,Y) vert} $$ . Depending on the application, we may want the property of zero distance for both perfect correlation and anti-correlation. This alternative definition satisfies that, besides setting a maximum distance between $X$ and $Y$ when they are completely uncorrelated. . 3. Variation of information: $$d_I(X,Y) = 1 - frac{I(X,Y)}{S(X,Y}$$ . Both correlation-based metrics above share the same limitation. They are only well defined if the relationship between $X$ and $Y$ is linear or, equivalently, if they follow a bivariate normal distribution. I have discussed in a previous post how information-theoretic quantities allow us to measure a broader class of relations. In this context, we can define above entropy-based distance metric called variation of information. Here, $S(X,Y)$ and $I(X,Y)$ are the joint entropy and mutual information between $X$ and $Y$, respectively. In this framework, the distance between $X$ and $Y$ vanishes if and only if they are independent. Check out my previous post for a discussion and proper definition of entropy and mutual information. I will skip this step here. . All three quantities defined above are true metrics, in the sense that they satisfy all the properties required by a metric: non-negativity, symmetry and triangle inequality. They then allow the construction of a topological structure in this space of features. Besides, all three metrics are normalized, such that $0 leq d leq 1$. . Let&#39;s define some functions to calculate these metrics: . 1. Correlation distance (two-sided): . def calculate_corr_distance_2side(X, Y): rho = np.corrcoef(np.array((X, Y)))[0,1] distance = np.sqrt((1-rho)/2) return distance . 2. Correlation distance (one-sided): . def calculate_corr_distance_1side(X, Y): rho = np.corrcoef(np.array((X, Y)))[0,1] distance = np.sqrt(1-np.abs(rho)) return distance . 3. Variation of information: . import numpy as np def calculate_entropy(X): # 1) Histograms the samples nbins = int(len(X)**(1/3)) p = np.histogram(X, bins=nbins, density=False)[0] p = p/np.sum(p)+1e-6 # 2) Calculates the entropy entropy = -np.sum(p*np.log2(p)) return entropy def calculate_joint_entropy(X, Y): # 1) Histograms the samples nbins = int(len(X)**(1/3)) p = np.histogram2d(X, Y, bins=nbins, density=False)[0] p = p/np.sum(p)+1e-6 # 2) Calculates the entropy entropy = -np.sum(p*np.log2(p)) return entropy def calculate_mutual_information(X, Y): S_X = calculate_entropy(X) S_Y = calculate_entropy(Y) S_XY = calculate_joint_entropy(X, Y) I = S_X+S_Y-S_XY return I def calculate_variation_of_information(X, Y): I = calculate_mutual_information(X, Y) S = calculate_joint_entropy(X, Y) distance = 1 - I/S return distance . . Numerical illustration . Let me now generate some sample datasets to illustrate the behaviour of the different metrics defined above. . Linear relationships . I&#39;ll start by generating samples from a bivariate normal distribution for $(X,Y)$. We can construct correlated samples from uncorrelated ones by using the Cholesky decomposition, as implemented below: . from scipy.linalg import eigh, cholesky from scipy.stats import norm def generate_correlated_samples(N, rho): # The desired covariance matrix. r = np.array([[1.0, rho], [rho, 1.0]]) # Generate samples from 2 independent normally distributed N(0,1) x = norm.rvs(size=(2, N)) # Compute the Cholesky decomposition. c = cholesky(r, lower=True) # Convert the data to correlated random variables. y = np.dot(c, x) return (y[0,:], y[1,:]) . . Let&#39;s consider three cases of different correlation structure: . rhos = [0, 0.5, -0.95] samples = [generate_correlated_samples(N=1000, rho=rho) for rho in rhos] . Let&#39;s now plot the datasets, together with the corresponding distances between $X$ and $Y$: . import matplotlib import matplotlib.pyplot as plt fig, axes = plt.subplots(1, 3, figsize=(14, 4)) for i, rho in enumerate(rhos): axes[i].plot(samples[i][0], samples[i][1], &#39;.&#39;, color=(0.8,0.5,0.5,0.5)) axes[i].set_xlabel(&quot;X&quot;) axes[i].set_ylabel(&quot;Y&quot;) axes[i].set_title(&quot;Correlation = &quot;+str(rho)+ &quot; n$d_ rho$ = &quot;+str(np.round(calculate_corr_distance_2side(samples[i][0], samples[i][1]),2))+ &quot;; $d_{ vert rho vert}$ = &quot;+str(np.round(calculate_corr_distance_1side(samples[i][0], samples[i][1]),2))+ &quot;; $d_I$ = &quot;+str(np.round(calculate_variation_of_information(samples[i][0], samples[i][1]),2))) plt.show() . . A few notes: . Case 1: As expected $d_{ vert rho vert}$ and $d_I$ estimate a distance close to 1 (maximum distance). Remember that, however, the two-sided correlation distance is defined such that $d_{ rho}=1$ when $X$ and $Y$ are perfectly uncorrelated. . | Case 2: All three metrics consider a smaller distance between $X$ and $Y$, consistent with the stronger correlation between them. . | Case 3: The two-side correlation distance is large, while the one-side correlation distance is small, because of the properties mentioned above. Variation of information is also smaller, because of the stronger relationship between $X$ and $Y$. . | . Finally, the different metrics seem to scale differently with respect to $ rho$. To better visualize this let&#39;s calculate all three metrics as we slowly increase the correlation coefficient from -1 to 1: . rhos = np.linspace(-1+1e-6, 1-1e-6, 200) samples = [generate_correlated_samples(N=5000, rho=rho) for rho in rhos] d_2side_rho = [calculate_corr_distance_2side(samples[i][0], samples[i][1]) for i in range(0, len(rhos))] d_1side_rho = [calculate_corr_distance_1side(samples[i][0], samples[i][1]) for i in range(0, len(rhos))] d_I = [calculate_variation_of_information(samples[i][0], samples[i][1]) for i in range(0, len(rhos))] . Plotting the results: . fig, axes = plt.subplots(1, 1, figsize=(6, 4)) axes.plot(rhos, d_2side_rho, color=(0.8,0.3,0.3,0.5), label=&quot;Two-side correlation distance&quot;) axes.plot(rhos, d_1side_rho, color=(0.3,0.3,0.8,0.5), label=&quot;One-side correlation distance&quot;) axes.plot(rhos, d_I, color=(0.3,0.3,0.3,0.5), label=&quot;Variation of information&quot;) axes.set_xlabel(&quot;Correlation coefficient $ rho_{XY}$&quot;) axes.set_ylabel(&quot;Distance $(X, Y)$&quot;) axes.legend() plt.show() . . Nonlinear relationships . Let&#39;s now consider a nonlinear relationship between $X$ and $Y$ in the form $Y=X^2 + epsilon$, and generate a few samples of increasing amplitude in the noise term $ epsilon$: . noise = [0.1, 0.5, 2.0] X = norm.rvs(size=(1, 1000))[0,:] samples = list() for value in noise: Y = X**2 + value*norm.rvs(size=(1, 1000))[0,:] Y = (Y-np.mean(Y))/np.std(Y) samples.append([X,Y]) . And now plotting the results: . fig, axes = plt.subplots(1, 3, figsize=(14, 4)) for i, rho in enumerate(noise): axes[i].plot(samples[i][0], samples[i][1], &#39;.&#39;, color=(0.8,0.5,0.5,0.3)) axes[i].set_xlabel(&quot;X&quot;) axes[i].set_ylabel(&quot;Y&quot;) axes[i].set_title(&quot;$d_ rho$ = &quot;+str(np.round(calculate_corr_distance_2side(samples[i][0], samples[i][1]),2))+ &quot;; $d_{ vert rho vert}$ = &quot;+str(np.round(calculate_corr_distance_1side(samples[i][0], samples[i][1]),2))+ &quot;; $d_I$ = &quot;+str(np.round(calculate_variation_of_information(samples[i][0], samples[i][1]),2))) plt.show() . . As expected, correlation-based metrics fail in recognizing the degree of dependence between $X$ and $Y$ while variation of information does not. Note that, variation of information is still relatively high, even in the left case of low noise. This is partially because of the degeneracy in the variables. Knowing $Y$ does not uniquely determine $X$, even in the absence of noise. . Let&#39;s better visualize how all three metrics scale as we slowly increase the amplitude of the noise term. We begin by generating the samples: . noise = np.linspace(0, 2, 200) X = norm.rvs(size=(1, 10000))[0,:] samples = list() for value in noise: Y = X**2 + value*norm.rvs(size=(1, 10000))[0,:] Y = (Y-np.mean(Y))/np.std(Y) samples.append([X,Y]) . Now we calculate the different metrics: . d_2side_rho = [calculate_corr_distance_2side(samples[i][0], samples[i][1]) for i in range(0, len(noise))] d_1side_rho = [calculate_corr_distance_1side(samples[i][0], samples[i][1]) for i in range(0, len(noise))] d_I = [calculate_variation_of_information(samples[i][0], samples[i][1]) for i in range(0, len(noise))] . And finally plot the results: . fig, axes = plt.subplots(1, 1, figsize=(6, 4)) axes.plot(noise, d_2side_rho, color=(0.8,0.3,0.3,0.5), label=&quot;Two-side correlation distance&quot;) axes.plot(noise, d_1side_rho, color=(0.3,0.3,0.8,0.5), label=&quot;One-side correlation distance&quot;) axes.plot(noise, d_I, color=(0.3,0.3,0.3,0.5), label=&quot;Variation of information&quot;) axes.set_xlabel(&quot;Amplitude of the noise term $ epsilon$&quot;) axes.set_ylabel(&quot;Distance $(X, Y)$&quot;) axes.legend() plt.show() . . Clearly, because of the non-linear relationship between $X$ and $Y$, both correlation-based metric completely fail in describing their decreasing inter-dependence. . Final notes: . Now that we have described both . An optimal clustering framework, in Part I of this series and; | Appropriate metrics to calculate the distance between pairs of features; | we can proceed to the final goal of performing optimal clustering of features. In the final Part III of this series, I will put all these ideas together and conduct several controlled numerical experiments to assess the performance of the entire framework. . References: . de Prado, M. M. L. (2020). Machine learning for asset managers. Cambridge University Press. | .",
            "url": "https://joaodmrodrigues.github.io/elements-financial-machine-learning/clustering/entropy/membership%20entropy/feature%20selection/variation%20of%20information/correlation%20distance/2021/02/13/optimal_feature_clustering_part2.html",
            "relUrl": "/clustering/entropy/membership%20entropy/feature%20selection/variation%20of%20information/correlation%20distance/2021/02/13/optimal_feature_clustering_part2.html",
            "date": " • Feb 13, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Optimal feature clustering - Part I",
            "content": "Introduction . In this series of articles (three in total), I will address the problem of clustering, specifically feature (or variable) clustering. Feature clustering appears in several processes associated with finance and systematic trading, including portfolio construction, feature selection, regime detection, etc. Part I is devoted to the construction of optimal clusters based on information-theoretic arguments. . I will use the fuzzy clustering framework to develop some of the ideas. Here, instead of assigning each point in the feature space to a definite cluster, a set of membership probabilities $p_x(i)$ are calculated, describing the degree of confidence in assigning point $x$ to cluster $i$. . As with many other clustering techniques, a fundamental problem is to infer the optimal number of clusters, which enters as a free parameter in many of the respective algorithms. I will show that as a by-product of the probabilistic nature of the fuzzy clustering framework, we can define information-theoretic measures about the quality of the clustering and use an entropy minimization argument to infer the optimal number of clusters. I have originally developed these ideas when I was at Imperial College London, in the context of data-driven detection of phases and phase transitions in physical systems made up of only a few particles (Rodrigues et al., 2020). . In the context of feature clustering, appropriate metrics have to be used to correctly calculate the &quot;distance&quot; between pairs of variables. This will be the subject of Part II, where I will discuss correlation-based and information-theoric-based metrics. I will also explain how to build an observation matrix and conduct the clustering process over a feature space of features. . Finally, in Part III I will conduct controlled numerical experiments and analyse the performance of the entire framework. . Note: While here the discussion will be centred around clustering of features, some of the techniques and ideas are completely general and applicable in many other contexts involving clustering. . Optimal clustering . As mentioned before, within the framework of fuzzy clustering, $p_x(i)$ is the probability of element $x$ - either a feature itself or an observation in a given feature space, in general - belonging to cluster $i$, with $i=1,2,...,k$ and $k$ the total number of clusters. Here, I will estimate these probabilities using the fc-means algorithm (Bezdek, 2013), implemented in the Python package fcmeans (Dias, 2019). . From the probabilities $p_x(i)$, we can define the membership entropy . $$S_x( { p_x(i) }) = - frac{1}{ mathrm{log}(k)} displaystyle sum_{i=1}^k p_x(i) mathrm{log}(p_x(i)),$$ . which quantifies the ambiguity in assigning observation $x$ to the available clusters. The least ambiguous case corresponds to $p_x(j) = 1$ and $p_x(i neq j)=0$ for a given cluster $j$, resulsting in $S_x=0$. On the other hand, a maximally ambiguous configuration $p_x(i) = 1/k$, leads to a maximum membership entropy $S_x=1$. . The $1/ mathrm{log}(k)$ term normalizes the membership entropy, such that configurations with different numbers of clusters can be correctly compared. This will be needed later to infer the optimal number of clusters. . Lastly, we define the representative cluster as that that, for a given observation $x$, maximizes the subset of probabilities $p_x(i)$. It is thus the most representative cluster associated with $x$. . Let&#39;s conduct numerical experiments to demonstrate these ideas. All the concepts described in this Part I are completely generic to any partitional clustering problem. . Fuzzy clustering and information-theoretic metrics . Let&#39;s define a function that calculates the membership probabilities $p_x(i)$ using the fcmeans package and calculates the . Representative clusters | Membership entropy of every observation | Total membership entropy (across all observations) | from fcmeans import FCM def cluster(n_clusters, features): # membership probabilities model = FCM(n_clusters=n_clusters).fit(features) p = model.u # representative cluster representative_cluster = np.argmax(p, 1) # membership entropy Sx = -np.sum(p*np.log(p), 1) / np.log(n_clusters) # total membership entropy (across the entire feature space) S = np.sum(Sx) return p, representative_cluster, Sx, S . . Simulated data . We now generate a sample dataset, corresponding to 5 clusters of 500 observation in total. Let&#39;s generate 3 cases of increasing spread among the observations: . N = 500 n_clusters = 5 blob_centers = [[0,0], [-1.0,1.0], [-1.0, -1.0], [1.0,-1.0], [1.0,1.0]] blobs_std = [0.25, 0.35, 0.45] from sklearn.datasets import make_blobs X_all = list() y_all = list() for std in blobs_std: X, y = make_blobs(n_samples=N, centers=blob_centers, cluster_std=[std]*n_clusters, n_features=2, random_state=0) X_all.append(X) y_all.append(y) . . Let&#39;s plot the dataset: . import numpy as np import matplotlib import matplotlib.pyplot as plt matplotlib.rc(&#39;text&#39;, usetex = True) font = {&#39;family&#39;: &#39;normal&#39;, &#39;size&#39;: 12} matplotlib.rc(&#39;font&#39;, **font) matplotlib.rcParams[&#39;figure.dpi&#39;]= 1000 fig, axes = plt.subplots(1, 3, figsize=(14, 4)) for i, ax in enumerate(axes): ax.scatter(X_all[i][:,0], X_all[i][:,1], marker=&#39;.&#39;, s=80, edgecolor=(0.6,0.6,0.6,0.5), facecolor=(0.4,0.4,0.4)) ax.set_ylabel(&#39;variable 1&#39;) ax.set_xlabel(&#39;variable 2&#39;) ax.set_xlim([-2.4, 2.4]) ax.set_ylim([-2.4, 2.4]) ax.set_xticks([-2, -1, 0, 1, 2]) ax.set_yticks([-2, -1, 0, 1, 2]) plt.show() . . Membership entropy and optimal number of clusters . As mentioned before, an optimal number of clusters can be inferred as that that minimizes the total membership entropy across our feature space. Let&#39;s see how this quantity varies as a function of the number of clusters, for all three cases above: . n_clusters_trials = np.arange(2, 10, 1) total_entropies_all = list() for X in X_all: total_entropies = list() for n in n_clusters_trials: _, _, _, total_entropy = cluster(n_clusters=n, features=X) total_entropies.append(total_entropy) total_entropies_all.append(total_entropies) . . And plotting the results: . fig, axes = plt.subplots(1, 3, figsize=(14, 4)) for i, ax in enumerate(axes): ax.plot([5, 5], [0, np.max(total_entropies_all)], color=(0.8,0.6,0.6), linewidth=2) ax.plot(n_clusters_trials, total_entropies_all[i], color=(0.46,0.46,0.46), linewidth=2) ax.set_xlabel(&#39;Number of clusters&#39;, ) ax.set_ylabel(&#39;Total membership entropy&#39;) ax.tick_params(axis=&quot;both&quot;) ax.tick_params(direction=&#39;in&#39;, bottom=True, top=True, left=True, right=True) ax.set_xlim([1.5, 9.5]) ax.set_xscale(&#39;linear&#39;) ax.set_yscale(&#39;linear&#39;) plt.show() . . Few observations about the results above: . The minimization of the membership entropy correctly predicts the number of clusters in case 1 and 2. | Case 3 is, according to the membership entropy, equally consistent with 4 and 5 clusters. Indeed, by looking at the previous plot, it is not at all possible to say if the central part is a different cluster and simply the overlap of the 4 outer clusters. | The overall membership entropy increases from left to right, quantifying the increasing overlap between clusters. | Final clustering . Now that we have inferred the optimal number of clusters to be 5, let&#39;s perform the final clustering, including collecting the representative cluster of each observation. . representative_cluster_all = list() entropies_all = list() for X in X_all: p, representative_cluster, Sx, S = cluster(n_clusters=5, features=X) representative_cluster_all.append(representative_cluster) entropies_all.append(Sx) . . The membership probabilities enclose full information about the clustering. They are however hard to visualize. We can create a lower-dimensional visualization of the results by assigning different colours to different representative clusters. Further, we can assign a transparency level proportional to the membership entropy of each observation, thus gauging a level of ambiguity in assigning it to the available clusters: . ### Color handles def make_rgb_transparent(rgb, alpha): bg_rgb = [1, 1, 1] return [alpha * c1 + (1 - alpha) * c2 for (c1, c2) in zip(rgb, bg_rgb)] colormap = matplotlib.cm.get_cmap(&#39;Accent&#39;) edgecolors = list() facecolors = list() for i in range(0, 5): edgecolors.append(make_rgb_transparent(rgb=colormap(1.0*i/(5-1)), alpha=1)) facecolors.append(make_rgb_transparent(rgb=colormap(1.0*i/(5-1)), alpha=0.65)) ### Plotting fig, axes = plt.subplots(1, 3, figsize=(14, 4)) for i, ax in enumerate(axes): color_seq = list() for j in range(0, X_all[i].shape[0]): color_seq.append(make_rgb_transparent(edgecolors[representative_cluster_all[i][j]], 1-entropies_all[i][j])) ax.scatter(X_all[i][:,0], X_all[i][:,1], marker=&#39;.&#39;, s=40, edgecolors=(0.6,0.6,0.6,0.5), c=color_seq) ax.set_ylabel(&#39;feature 1&#39;) ax.set_xlabel(&#39;feature 2&#39;) ax.set_xlim([-2.4, 2.4]) ax.set_ylim([-2.4, 2.4]) ax.set_xticks([-2, -1, 0, 1, 2]) ax.set_yticks([-2, -1, 0, 1, 2]) . . As expectable, the membership entropy increases in the regions between clusters. . Cluster quality . Finally, we can quantify the quality of the different clusters by calculating the intra-cluster mean membership entropy. Let&#39;s generate a different dataset to demonstrate this: . N = 400 blob_centers = [[2, 0], [2*np.cos(2*np.pi/3), 2*np.sin(2*np.pi/3)], [2*np.cos(4*np.pi/3), 2*np.sin(4*np.pi/3)]] blobs_std = [0.1, 0.3, 0.6] X, y = make_blobs(n_samples=N, centers=blob_centers, cluster_std=blobs_std, n_features=2, random_state=0) . . Again, inferring the optimal number of clusters by minimizing the membership entropy: . n_clusters_trials = np.arange(2, 10, 1) total_entropies = list() for n in n_clusters_trials: _, _, _, total_entropy = cluster(n_clusters=n, features=X) total_entropies.append(total_entropy) . . The optimal number of clusters is correctly inferred to be 3, as shown in the figure below. Let&#39;s then calculate the final clusters: . p, representative_cluster, Sx, S = cluster(n_clusters=3, features=X) . Plotting all the results: . ### Color handles edgecolors = list() facecolors = list() for i in range(0, 3): edgecolors.append(make_rgb_transparent(rgb=colormap(1.0*i/(3-1)), alpha=1)) facecolors.append(make_rgb_transparent(rgb=colormap(1.0*i/(3-1)), alpha=0.65)) fig, axes = plt.subplots(1, 3, figsize=(14, 4)) ### Sample dataset axes[0].scatter(X[:,0], X[:,1], marker=&#39;.&#39;, s=80, edgecolor=(0.6,0.6,0.6,0.5), facecolor=(0.4,0.4,0.4)) axes[0].set_ylabel(&#39;feature 1&#39;) axes[0].set_xlabel(&#39;feature 2&#39;) ### Minimization of the total membership entropy axes[1].plot([3, 3], [0, np.max(total_entropies)], color=(0.8,0.6,0.6), linewidth=2) axes[1].plot(n_clusters_trials, total_entropies, color=(0.46,0.46,0.46), linewidth=2) axes[1].set_xlabel(&#39;Number of clusters&#39;, ) axes[1].set_ylabel(&#39;Total membership entropy&#39;) axes[1].tick_params(axis=&quot;both&quot;) axes[1].tick_params(direction=&#39;in&#39;, bottom=True, top=True, left=True, right=True) axes[1].set_xlim([1.5, 9.5]) axes[1].set_xscale(&#39;linear&#39;) axes[1].set_yscale(&#39;linear&#39;) ### Final clusters color_seq = list() for j in range(0, X.shape[0]): color_seq.append(make_rgb_transparent(edgecolors[representative_cluster[j]], 1-Sx[j])) axes[2].scatter(X[:,0], X[:,1], marker=&#39;.&#39;, s=40, edgecolors=(0.6,0.6,0.6,0.5), c=color_seq) axes[2].set_ylabel(&#39;feature 1&#39;) axes[2].set_xlabel(&#39;feature 2&#39;) plt.show() . . And finally, calculate the intra-cluster mean membership entropy: . Si = list() for cluster in set(representative_cluster): probs = p[np.argmax(p, 1)==cluster, :] entropy = -np.sum(probs*np.log(probs), 1) / np.log(probs.shape[1]) Si.append(np.mean(entropy)) _=[print(&quot;Mean membership entropy across cluster {0} = {1}&quot;.format(i, np.round(Si[i], 2))) for i in range(0, len(Si))] . Mean membership entropy across cluster 0 = 0.02 Mean membership entropy across cluster 1 = 0.13 Mean membership entropy across cluster 2 = 0.3 . Final notes . The fc-means algorithm involves minimizing a given objective function. This minimization is not convex and, there is the change of being stuck at a local minimum. In more complex datasets than those generated above, it may be crucial to use different seeds in the initialization of the algorithm and do ensemble statistics over the final results, for instance, in finding the optimal number of clusters. | While I have conducted these experiments starting from the fc-means algorithm, the ideas described here can be applied to any other clustering algorithm that performs soft (probabilistic clustering), like Gaussian mixture models, for instance. | Check Part II and Part III of this series... . References: . Rodrigues, J. D., Dhar, H. S., Walker, B. T., Smith, J. M., Oulton, R. F., Mintert, F., &amp; Nyman, R. A. (2020). Unsupervised Learning of the Fuzzy Phases of Small Photonic Condensates. | Bezdek, J. C. (2013). Pattern recognition with fuzzy objective function algorithms. Springer Science &amp; Business Media. | Dias, M. L. D. (2019). fuzzy-c-means: An implementation of Fuzzy C-means clustering algorithm. Zenodo. https://doi.org/10.5281/zenodo.3066222 | .",
            "url": "https://joaodmrodrigues.github.io/elements-financial-machine-learning/clustering/entropy/membership%20entropy/feature%20selection/variation%20of%20information/correlation%20distance/2021/02/12/optimal_feature_clustering_part_I.html",
            "relUrl": "/clustering/entropy/membership%20entropy/feature%20selection/variation%20of%20information/correlation%20distance/2021/02/12/optimal_feature_clustering_part_I.html",
            "date": " • Feb 12, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Trading with the Kelly criterion",
            "content": "Motivation . Forecasting the direction of the next price movement is only part of the problem of trading. A proper capital allocation to that forecast its equally significant, althought is importance is often underestimated. Here, I&#39;m considering the problem of capital allocation on a single strategy, and not that of optimal portfolio allocation when we are investing in more than one instrument, like the framework of Modern Portfolio Theory. . A remarkable insight into this subject has been given by (Kelly, 1956). A good introduction to the subject can be found in Wikipedia. Thorpe also has a very interesting technical review (Thorp, 2008) and (Cover, 1999), like Kelly in its original paper, describes the interesting connections with information theory. . Kelly addresses the problem of optimal capital allocation under a statistically favourable (in expectation) betting opportunity. Two important conclusions from his work are: . Even in the presence of a favourable bet, over-allocation of capital will lead to ruin in the long run with probability 1. | Knowing the probability of the possible outcomes allows us to optimally size our bet (or position) in the sense of maximizing the expected growth rate of our portfolio. . Note: While point 1 may seem counterintuitive at first, think that if your portfolio falls 50%, it has to grow 100% to come back to its initial value. | Mathematical formulation . Let&#39;s consider the following formulation of the Kelly criterion: . Let&#39;s define $R_t$ as the random variable describing the returns of our strategy (or returns of a price time-series) at time $t$. The portfolio value at time $t+1$ is then the random variable $P_{t+1}$ given by . $$ P_{t+1} = p_t (1+ f R_t) $$ . with $p_t$ the portfolio value at $t$ and $f$ the respective fraction allocated to the strategy. Note that, $f$ can be negative, meaning that we are going short on the strategy (or instrument). If we have leverage available, $ vert f vert$ can also be greater than 1. The portfolio value $P_{t+1}$ can also be written as . $$ P_{t+1} = e^{ Lambda}, $$ . assuming, without loss of generality, $p_t = 1$. Here, $ Lambda = mathrm{log}(1 + f R_t)$ is the random variable describing the portfolio growth rate. The Kelly criterion gives the optimal value of $f$ in the sense of maximizing the expected value of $ Lambda$. If $R_t$ follows a normal distribution $ mathcal{N} ( mu_r, sigma_r)$, (Thorp, 2008) has shown that the Kelly-optimal value of $f$ is given by . $$ f = frac{ mu_r}{ sigma_r^2}. $$ . Note: In order to study the long-term portfolio growth, we are actually interested in the random variable . $$ P_{t+1} = p_1 (1+ f R_1)(1+ f R_2) ... (1+ f R_t). $$ . However, we are assuming that the $R_1$, $R_2$, ..., are independent. In this case, we can simplify the problem into the formulation above. . Monte-Carlo simulation . In order to appreciate the power of the Kelly criterion, we are going to conduct Monte-Carlo simulations, where at each time step the returns of our price time series are going to be drawn from a normal distribution $ mathcal{N} ( mu_r, sigma_r)$. However, in order to simulate a more realistic and dynamical scenario, $ mu_r$ and $ sigma_r$ will themselves be modelled as stochastic processes as well. In particular, I am going to model $ mu_{r,t}$ via an Ornstein-Ulhenbeck process, and $ sigma_{r,t}$ via a geometric Ornstein-Ulhenbeck process. The latter, for instance, allows the time-series to become heteroskedastic. . The Ornstein-Ulhenbeck process is defined as: . $$ dY_t = - frac{(Y_t - mu)}{ tau}dt + sigma sqrt{ frac{2}{ tau}} dW_t, $$ . with $ mu$ and $ sigma$ the process mean and standard deviation, respectively, and $W_t$ is Brownian motion. The geometric version is defined as . $$ dY_t = - frac{(Y_t - mu)}{ tau}dt + sigma Y_t dW_t. $$ . We can numerically integrate the stochastic differential equations above using the Euler-Maruyama method, implemented in the functions below: . Note: The entire code shown in this article has been written for the purpose of clarity rather than efficiency . import numpy as np def Ornstein_Ulhenbeck(T, dt, mu, sigma, tau, Y0): # Initializations Y = list() t = np.arange(0, T, dt) Y.append(Y0) # Parameters N = len(t) sigma_term = sigma*np.sqrt(2.0/tau)*np.sqrt(dt) normal_draws = np.random.normal(loc=0.0, scale=1.0, size=N) # Integration for i in range(1, N): Y.append(Y[-1] - dt*(Y[-1]-mu)/tau + sigma_term*normal_draws[i]) return np.array(Y) def geometric_Ornstein_Ulhenbeck(T, dt, mu, sigma, tau, Y0): # Initializations Y = list() t = np.arange(0, T, dt) Y.append(Y0) # Parameters N = len(t) sigma_term = sigma*np.sqrt(dt) normal_draws = np.random.normal(loc=0.0, scale=1.0, size=N) # Integration for i in range(1, N): Y.append(Y[-1] - dt*(Y[-1]-mu)/tau + sigma_term*Y[-1]*normal_draws[i]) return np.array(Y) . . Let&#39;s simulate 1000 price bars: . Stochastic path for the mean of the returns - $ mu_{r,t}$ . T = 1000 dt = 1 mu = 0 sigma = 0.002 tau = 1 path_mean = Ornstein_Ulhenbeck(T=T, dt=dt, mu=mu, sigma=sigma, tau=tau, Y0=mu) . And plotting the results: . import matplotlib.pyplot as plt fig, axes = plt.subplots(1, 1, figsize=(14, 4)) axes.plot(path_mean, &#39;-&#39;, color=(0.8,0.5,0.5,1.0)) axes.set_xlabel(&quot;Bar&quot;) _=axes.set_ylabel(&quot;Path for returns mean&quot;) . . Stochastic path for the volatility of the returns - $ sigma_{r,t}$ . T = 1000 dt = 1 mu = 0.02 sigma = 0.01 tau = 10 path_std = geometric_Ornstein_Ulhenbeck(T=T, dt=dt, mu=mu, sigma=sigma, tau=tau, Y0=mu) . Plotting the results: . import matplotlib.pyplot as plt fig, axes = plt.subplots(1, 1, figsize=(14, 4)) axes.plot(path_std, &#39;-&#39;, color=(0.8,0.5,0.5,1.0)) axes.set_xlabel(&quot;Bar&quot;) _=axes.set_ylabel(&quot;Path for returns volatility&quot;) . . Price path . From the paths generated above, we can now draw the returns $R_t sim mathcal{N} ( mu_{r,t}, sigma_{r,t})$ and the resulting price series $p_t = p_1 displaystyle prod_{t&#39;= 1}^t (1+r_{t&#39;})$: . path_returns = np.random.normal(loc=path_mean, scale=path_std) path_price = 100*np.cumprod(1+path_returns) . fig, axes = plt.subplots(1, 2, figsize=(14, 4)) axes[0].plot(path_returns, &#39;-&#39;, color=(0.8,0.5,0.5,1.0)) axes[0].set_xlabel(&quot;Bar&quot;) axes[0].set_ylabel(&quot;Realized returns&quot;) axes[0].set_title(&quot;Returns&quot;) axes[1].plot(path_price, &#39;-&#39;, color=(0.5,0.5,0.8,1.0)) axes[1].set_xlabel(&quot;Bar&quot;) axes[1].set_ylabel(&quot;Realized price&quot;) axes[1].set_title(&quot;Price&quot;) plt.show() . . The parameters above have been chosen such that the hit ratio - fraction of bars where the expected return $ mu_{r,t}$ is of the same sign as the realized return $r_t$ - varies approximately between 0.5 and 0.6. For this particular realization: . hit_ratio = np.sum(np.sign(path_returns*path_mean)&gt;0)/len(path_returns) print(hit_ratio) . 0.516 . Allocation strategies . Let&#39;s create a function that calculates the portfolio growth. It takes as parameters the initial portfolio value, the fraction of the portfolio invested at every bar (negative for short positions and positive for long positions), and the realized price returns . I am also assuming that we are effectively bankrupted it at any point our porfolio drops below 1 percent of its initial value: . def calculate_portfolio_growth(portfolio_initial, fractions, price_returns): N = len(fractions) strategy_returns = fractions*price_returns portfolio_growth = portfolio_initial*np.cumprod(1+strategy_returns) if True in [value&lt;=1e-2*portfolio_initial for value in portfolio_growth]: bust_ind = np.min(np.where(portfolio_growth&lt;1e-2*portfolio_initial)[0]) portfolio_growth[bust_ind:] = 0 return portfolio_growth . We are going to assume maximum available leverage of 10 and three different allocation strategies: . Full leverage | Half leverage | Optimal Kelly allocation (limited to a maximum of 10x leverage) | portfolio_initial = 1 leverage = 10 ##### Strategy 1 - full leverage fractions1 = leverage * np.sign(path_mean) portfolio1 = calculate_portfolio_growth(portfolio_initial=portfolio_initial, fractions=fractions1, price_returns=path_returns) ##### Strategy 2 - half leverage fractions2 = 0.5*leverage * np.sign(path_mean) portfolio2 = calculate_portfolio_growth(portfolio_initial=portfolio_initial, fractions=fractions2, price_returns=path_returns) ##### Strategy 3 - Kelly fractions3 = path_mean/path_std**2 fractions3[fractions3&gt;leverage] = leverage fractions3[fractions3&lt;-leverage] = -leverage portfolio3 = calculate_portfolio_growth(portfolio_initial=portfolio_initial, fractions=fractions3, price_returns=path_returns) . Let&#39;s now plot the performance of the different allocation strategies: . fig, axes = plt.subplots(1, 1, figsize=(7, 5)) axes.plot(portfolio1, &#39;-&#39;, label=&quot;Full leverage&quot;, color=(0.8,0.5,0.5,1.0)) axes.plot(portfolio2, &#39;-&#39;, label=&quot;Half leverage&quot;, color=(0.5,0.5,0.8,1.0)) axes.plot(portfolio3, &#39;-&#39;, label=&quot;Kelly optimal&quot;, color=(0.5,0.7,0.7,1.0)) axes.legend() axes.set_xlabel(&quot;Bar&quot;) axes.set_ylabel(&quot;Portfolio value&quot;) axes.set_yscale(&quot;log&quot;) . . As stated before, which we can now empirically corroborate, one of the key insights of the Kelly criterion is that, even in the presence of a favorable betting (or trading) opportunity, overallocation will eventually lead to ruin. . In the realization above, the full leverage allocation does lead to ruin. The half leverage strategy has a positive return but underperforms the optimal Kelly allocation. . We can calculate the average absolute leverage in the Kelly allocation: . print(np.round(np.mean(np.abs(fractions3)), 2)) . 5.09 . Thus, despite the similar used leverage (on average), the Kelly strategy outperforms the constant 5x leverage strategy. . A better way to conduct this analysis is through the Sharp ratio, which can be shown to be maximized (in expectation) by the Kelly-optimal allocation. . def calculate_sharp_ratio(portfolio): N = len(portfolio) if True in [value==0 for value in portfolio]: bust_ind = np.min(np.where(portfolio==0)[0]) portfolio = portfolio[:bust_ind] returns = (portfolio[1:]-portfolio[0:-1])/portfolio[0:-1] sharp_ratio = np.sqrt(252)*np.mean(returns)/np.std(returns) return sharp_ratio . In the above, we are associating each bar to a trading day, and annualizing the Sharp ratio. The results: . print(&quot;Sharp ratio, full leverage =&quot;, np.round(calculate_sharp_ratio(portfolio1),2)) print(&quot;Sharp ratio, half leverage =&quot;, np.round(calculate_sharp_ratio(portfolio2),2)) print(&quot;Sharp ratio, Kelly optimal =&quot;, np.round(calculate_sharp_ratio(portfolio3),2)) . . Sharp ratio, full leverage = -0.84 Sharp ratio, half leverage = 1.02 Sharp ratio, Kelly optimal = 1.67 . Note that, an overall multiplicative factor in the used leverage does not change the Sharp ratio. The reason why the Sharp ratio may be different between the full- and the half-leverage strategies is because of the possibility of going bankrupt. . Ensemble statistics . While the results above corroborate our expectations about the Kelly allocation, their statistical significance is somewhat meaningless, because we have considered a single realization, albeit a long one with a total of 1000. . I am going to perform many realizations (200) of the experiment above and check the performance statistics. . Note: The processes simulated here are essentially ergodic, meaning that $m$ realizations of $N$ bars each, is equivalent to a single realization of $mN$ bars, in terms of their statistical properties. For the sake of simplicity, I&#39;m going to choose the former. . n_runs = 200 strategy1 = list() strategy2 = list() strategy3 = list() for i in range(0, n_runs): # Price path path_mean = Ornstein_Ulhenbeck(T=1000, dt=1, mu=0, sigma=0.002, tau=1, Y0=0) path_std = geometric_Ornstein_Ulhenbeck(T=1000, dt=1, mu=0.02, sigma=0.01, tau=10, Y0=0.02) path_returns = np.random.normal(loc=path_mean, scale=path_std) path_price = 100*np.cumprod(1+path_returns) # Full leverage fractions1 = leverage * np.sign(path_mean) portfolio1 = calculate_portfolio_growth(portfolio_initial=portfolio_initial, fractions=fractions1, price_returns=path_returns) strategy1.append(calculate_sharp_ratio(portfolio1)) # Half leverage fractions2 = 0.5 * leverage * np.sign(path_mean) portfolio2 = calculate_portfolio_growth(portfolio_initial=portfolio_initial, fractions=fractions2, price_returns=path_returns) strategy2.append(calculate_sharp_ratio(portfolio2)) # Kelly fractions3 = path_mean/path_std**2 fractions3[fractions3&gt;leverage] = leverage fractions3[fractions3&lt;-leverage] = -leverage portfolio3 = calculate_portfolio_growth(portfolio_initial=portfolio_initial, fractions=fractions3, price_returns=path_returns) strategy3.append(calculate_sharp_ratio(portfolio3)) sharp_ratio = np.array([strategy1, strategy2, strategy3]).T strategy_labels = [&quot;Full leverage&quot;, &quot;Half leverage&quot;, &quot;Kelly optimal&quot;] . . And now plotting the results: . fig, axes = plt.subplots(1, 1, figsize=(6, 4)) axes.boxplot(sharp_ratio) axes.set_xticklabels(strategy_labels, rotation=0) axes.set_ylabel(&quot;Sharp ratio&quot;) plt.tight_layout() plt.show() print(&quot;Mean Sharp ratio, full leverage =&quot;, np.round(np.mean(sharp_ratio[:,0]),2)) print(&quot;Mean Sharp ratio, half leverage =&quot;, np.round(np.mean(sharp_ratio[:,1]),2)) print(&quot;Mean Sharp ratio, Kelly optimal =&quot;, np.round(np.mean(sharp_ratio[:,2]),2)) . . Mean Sharp ratio, full leverage = 1.3 Mean Sharp ratio, half leverage = 1.75 Mean Sharp ratio, Kelly optimal = 2.16 . Now we have statistically significant results demonstrating the outperformance of the Kelly allocation strategy. The Sharp ratio of the full-leverage strategy is highly left-skewed, due to the many times the strategy goes bankrupt. . Note: Quantitatively, the results shown here are strongly dependent on the parameters chosen in the Monte-Carlo simulation. One may even wonder if I&#39;m not somehow overfitting these parameters in order to arrive at the expected result. However, running the experiment for different sets of parameters yields that the Kelly allocation is systematically the one that shows better performance. . Final notes . I would like to end this article with a few notes: . I&#39;m applying the Kelly criterion in a slightly different way than usual. We typically consider the statistics of the returns of a given strategy, or instrument, and then calculate the optimal allocation fraction, which does not vary from one bar to the other. Then the task is to continuously rebalance the portfolio as to maintain that constant allocation fraction. Here, I&#39;m assuming that I am in the presence of a fully probabilistic pricing model which, at each bar, outputs the full probability distribution of the next price return. Given the assumption of independence between these distributions, I&#39;m conjecturing, but not proving, that by calculating the optimal Kelly fraction at each bar I&#39;m still maximizing the long-run expected growth rate of my portfolio, in expectation. | I constructed the simulations above assuming the returns to be normally distributed. While this is not a terrible assumption, it may not be a good one depending on the situation. The advantage of normally-distributed returns is the close-form solution for the optimal Kelly fraction. For a generic distribution, however, we can perform Monte-Carlo simulations to infer the optimal Kelly fraction. | By construction, in the controlled experiment described here, I know exactly the probability distribution of returns. In a real application, while we can develop full probabilistic models in complete analogy with the ideas described here, one must consider the uncertainty about the model itself. This may mean reducing, for instance, using a fraction of the optimal Kelly fraction to reduce the risk of model uncertainty. | References: . Kelly, J. L. (1956). A new interpretation of information rate. The Bell System Technical Journal, 35(4), 917–926. https://doi.org/10.1002/j.1538-7305.1956.tb03809.x | Thorp, E. O. (2008). The Kelly criterion in blackjack sports betting, and the stock market. In Handbook of asset and liability management (pp. 385–428). Elsevier. | Cover, T. M. (1999). Elements of information theory. John Wiley &amp; Sons. | .",
            "url": "https://joaodmrodrigues.github.io/elements-financial-machine-learning/kelly%20criterion/monte%20carlo/2021/02/07/kelly_criterion_in_trading.html",
            "relUrl": "/kelly%20criterion/monte%20carlo/2021/02/07/kelly_criterion_in_trading.html",
            "date": " • Feb 7, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "Mutual information for feature selection",
            "content": "Motivation . In this article, I will explore information-theoretic quantities (mutual information) to perform feature selection for models on continuous variables, like a sequence of price returns, for instance. Mutual information offers many advantages, including: . Model-independent feature selection: Many feature selection techniques are inherent to a particular class of models. For instance, boruta, gini, or mean impurity decrease use tree-based models to rank the importance among a set of features. While there is an obvious value in selecting features whose predictive power is better leveraged by a particular class of models, this approach may lead to the drop of informative features if the end model is not of the same class as that used for feature selection. In this context, mutual information offers a complete model-agnostic approach to feature selection. . | Full distribution feature selection: If we are trying to model a continuous variable, most feature selection techniques end up selecting features that do better in predicting the mean of the target variable. If we are trying to forecast the return of a given price series, for instance, it is as important to predict its mean as it is to predict is uncertainty (volatility), which will allow a better sized allocation to that particular strategy or forecast. This means that we often may benefit from selecting features that carry information about different aspects of the distribution of our target, and not only its mean. Mutual information does exactly that. Even if we are working with classification models, which output buy and sell signals according to some rules, it is extremely important to have a way to model the confidence of these signals. For instance, (De Prado, 2018) describes using meta-labeling and the training of a surrogate model to predict the confidence on the buy and sell signals derived from the principal model. The best features for this surrogate model may be different than those of the first model. . | Two different kinds of relationships . Let&#39;s conduct a controlled experiment using two different scenarios: . Variable $X$ (cause) partially determines the mean of variable $Y$ (effect) | Variable $X$ (cause) partially determines the scale (standard deviation) of variable $Y$ (effect) | For the sake of simplicity, let&#39;s restrict ourselves to normal distributions here. . Let&#39;s define a function that generates these samples: . Note: The entire code shown in this article has been written for the purpose of clarity rather than efficiency . import numpy as np def normalize(sample): return (sample-np.mean(sample))/np.std(sample) def generate_samples(N, dependence_coef, which_param): ### Cause samples_cause = np.random.normal(loc=0.0, scale=1.0, size=N) ### Effect inherent_noise = np.random.normal(loc=0.5, scale=1.0, size=N) param = normalize((1-dependence_coef)*inherent_noise + dependence_coef*samples_cause) samples_effect = list() for i in range(0, N): if which_param == 1: # relationship on the mean mean = param[i] scale = 1.0 if which_param == 2: # relationship on the scale mean = np.random.normal(loc=np.random.normal(loc=0, scale=1.0)) scale = np.exp(param[i]) [samples_effect.append(np.random.normal(loc=mean, scale=scale))] return [normalize(samples_cause), normalize(samples_effect)] . . Note that we are allowing a varying level of &quot;causation&quot; between $X$ and $Y$, determined by dependence_coef which varies between 0 (no relation) and 1 (strong relation). Also, strong relation does not imply a perfect correlation between the variables. We are constantly drawing points from univariate normal distributions, where the parameters of the distribution of $Y$ - either mean or scale - depend on the value of $X$, at each observation. This ensures a more complex and non-trivial stochastic relation between the two random variables. . Let&#39;s generate these samples, assuming a dependence coefficient of 0.5: . N = 10000 dependence_coef = 0.5 # Relationship on the mean (cause_mean, effect_mean) = generate_samples(N=N, dependence_coef=dependence_coef, which_param=1) # Relationship on the scale (cause_scale, effect_scale) = generate_samples(N=N, dependence_coef=dependence_coef, which_param=2) . . And now let&#39;s plot the samples: . import matplotlib.pyplot as plt fig, axes = plt.subplots(1, 2, figsize=(10, 4), constrained_layout=True) axes[0].plot(cause_mean, effect_mean, &#39;.&#39;, color=(0.8,0.5,0.5,0.2)) axes[0].set_xlabel(&quot;Cause - X&quot;) axes[0].set_ylabel(&quot;Effect - Y&quot;) axes[0].set_title(&quot;Relation on the mean&quot;) axes[1].plot(cause_scale, effect_scale, &#39;.&#39;, color=(0.8,0.5,0.5,0.2)) axes[1].set_xlabel(&quot;Cause - X&quot;) axes[1].set_ylabel(&quot;Effect - Y&quot;) axes[1].set_title(&quot;Relation on the scale&quot;) _=plt.suptitle(&quot;Dependence coefficient = &quot;+str(dependence_coef)) . . As visible from above, on the left-hand side, $X$ is a good feature to use in predicting the mean of $Y$, but completely unrelated to its variance, which is completely stochastic by construction. On the other hand, on the right-hand side, $X$ is completely unrelated to the mean of $Y$, but it&#39;s moderately related to its scale. . Let&#39;s check other dependence coefficients: . Note: The way I constructed the &quot;Relation on the mean&quot; above results in an essentially linear relationship between $X$ and $Y$, which could be quantified by their respective covariance. However, covariance and correlation fail when the relationship between the mean of $X$ and $Y$ is nonlinear, whereas mutual information does not. The &quot;Relation on the scale&quot; construction, however, goes beyond both linear and non-linear relationships between the means of $X$ and $Y$. Despite that, and as I will demonstrate now, mutual information remains able to quantify the strength of this dependence. . Entropy, Joint Entropy and Mutual Information . I&#39;m going to quickly review the definition of entropy, joint entropy, and mutual information. A more detailed, yet simple, introduction to the subject can be found on Wikipedia, for instance. For a more complete description, (Cover, 1999) is a great reference. . For a discrete random variable $X$, we can define the Shannon entropy as . $$S(X) = - displaystyle sum_{i=1}^N p(x_i) mathrm{log}_2 [ p(x_i) ], $$ . and the joint entropy of $X$ and $Y$ as . $$S(X,Y) = - displaystyle sum_{i=1}^{N_x} displaystyle sum_{j=1}^{N_y} p(x_i, y_j) mathrm{log}_2 [ p(x_i, y_j) ].$$ . Note that, if $X$ and $Y$ are independent, $S(X,Y) = S(X) + S(Y)$. The mutual information can then be defined as . $$I(X,Y) = S(X) + S(Y) - S(X,Y),$$ . thus measuring the &quot;amount&quot; of information that is shared between $X$ and $Y$. As such, if $X$ and $Y$ are independent, $I(X,Y)=0$. An equivalent definition of mutual information can be written in terms of the conditional entropy: . $$I(X,Y) = S(X) - S(X|Y) = S(Y) - S(Y|X).$$ . We can then understand the mutual information as the information that we get about $X$ by knowing only $Y$, or vice versa. . Note: The choice of logarithm of base 2 above is somehow arbitrary, changing only the units we use to measure the &quot;quantity&quot; of information. The base 2 choice allows for this quantification to be made in terms of number of bits. . Sample estimation . While the theoretical definitions are simple and straightforward, robustly estimating these quantities from sample data is often tricky, especially when dealing with continuous random variables. Given that we are using synthetic data here, we can produce as large samples as we want, getting good statistical convergence if so desired. We thus take the simplest approach possible of histogramming the observations and applying the above definitions directly. . Let&#39;s define some functions: . def calculate_entropy(X): # 1) Histograms the samples nbins = int(len(X)**(1/3)) p = np.histogram(X, bins=nbins, density=False)[0] p = p/np.sum(p)+1e-6 # 2) Calculates the entropy entropy = -np.sum(p*np.log2(p)) return entropy def calculate_joint_entropy(X, Y): # 1) Histograms the samples nbins = int(len(X)**(1/3)) p = np.histogram2d(X, Y, bins=nbins, density=False)[0] p = p/np.sum(p)+1e-6 # 2) Calculates the entropy entropy = -np.sum(p*np.log2(p)) return entropy def calculate_mutual_information(X, Y): S_X = calculate_entropy(X) S_Y = calculate_entropy(Y) S_XY = calculate_joint_entropy(X, Y) I = S_X+S_Y-S_XY return I . . Dealing with discretization scaling . From the point of view of estimating entropy and joint entropy, the discretization procedure above introduces a scaling that needs to be controlled for. . To deal with this issue, besides estimating the mutual information for the original sample $(x_i, y_i)$ - $I_{ mathrm{sample}}$ - we are going to estimate the mutual information on a number of datasets where the observations of one of the original variables, say $Y$, are randomly permutated - $I_{ mathrm{perm}}^j$. We can then defined the mutual information score . $$s_I = frac{I_{ mathrm{sample}} - mathrm{mean}(I_{ mathrm{perm}}^j)}{ mathrm{sd}(I_{ mathrm{perm}}^j)}.$$ . By doing this normalization, we are arriving at a quantity that is insensitive to scaling issues arising from the discretization of $X$ and $Y$. In essence, $s_I$ measures the confidence, in terms of the number of standard deviations, that the relation between $X$ and $Y$ is not random. . Some code: . def calculate_mutual_information_score(X, Y, n_perm): # Mutual information on original samples I = calculate_mutual_information(X=X, Y=Y) # Mutual information on randomly shuffled data I_perm = list() ind = np.arange(len(Y)) for i in range(0, n_perm): np.random.shuffle(ind) Y_shuffled = Y[ind] I_perm.append(calculate_mutual_information(X=X, Y=Y_shuffled)) # Calculates the mutual information score mi_score = (I-np.mean(I_perm))/np.std(I_perm) return mi_score . . Let&#39;s now conduct some estimations of the mutual information score. . Let&#39;s begin with a small dependence between $X$ and $Y$ (here, $X$ related with the mean of $Y$): . (cause, effect) = generate_samples(N=100000, dependence_coef=0.05, which_param=1) n_perm = 100 mi_score = calculate_mutual_information_score(X=cause, Y=effect, n_perm=n_perm) print(np.round(mi_score,1)) . . 0.9 . and a slighly stronger relation: . (cause, effect) = generate_samples(N=100000, dependence_coef=0.20, which_param=1) n_perm = 100 mi_score = calculate_mutual_information_score(X=cause, Y=effect, n_perm=n_perm) print(np.round(mi_score,1)) . . 67.9 . Let&#39;s do a more systematic experiment, by slowly increasing the dependence coefficient from 0 to 1, and looking at the mutual information score for the 2 cases we have been considering - mean and scale relation: . dependence_coefs = np.linspace(0, 1, 20) mi_scores_mean = list() mi_scores_scale = list() for coef in dependence_coefs: ### On mean samples = generate_samples(N=100000, dependence_coef=coef, which_param=1) samples_cause = normalize(samples[0]) samples_effect = normalize(samples[1]) mi_scores_mean.append(calculate_mutual_information_score(X=samples_cause, Y=samples_effect, n_perm=50)) ### On scale samples = generate_samples(N=100000, dependence_coef=coef, which_param=2) samples_cause = normalize(samples[0]) samples_effect = normalize(samples[1]) mi_scores_scale.append(calculate_mutual_information_score(X=samples_cause, Y=samples_effect, n_perm=50)) . . And now plotting the results: . fig, axes = plt.subplots(1, 2, figsize=(10, 3)) axes[0].plot(dependence_coefs, mi_scores_mean, &#39;-&#39;, color=(0.8,0.5,0.5,1.0)) axes[0].set_xlabel(&quot;Dependence coeficient&quot;) axes[0].set_ylabel(&quot;Mutual information score&quot;) axes[0].set_title(&quot;Relation on the mean&quot;) axes[1].plot(dependence_coefs, mi_scores_scale, &#39;-&#39;, color=(0.8,0.5,0.5,1.0)) axes[1].set_xlabel(&quot;Dependence coeficient&quot;) axes[1].set_ylabel(&quot;Mutual information score&quot;) axes[1].set_title(&quot;Relation on the scale&quot;) plt.show() . . We correctly infer the increasing strength of the relationship between $X$ and $Y$. Note that, we are arriving at such large values of the mutual information score (or equivalently, such high confidence about the non-randomness of the relationship) because of the large number of points in our samples (100000). If we re-run the experiment with 10000 points we obtain: . Dealing with sample fluctuations . In any statistical estimation problem, we are subject to the problem of sample fluctuations. Even if our data-generating process is stationary, which is the case here, different samples will lead to different mutual information scores. . The problem is more severe if the data generating process is not stationary, which is often the case in financial time series. In this case, regime or structural shifts can change the relation between variables over time. The most we are left to do is to investigate the non-uniformity of our sample using empirical techniques, like resampling, and analyze inter-sample variations. . While bootstrap and bagging, for instance, would be appropriate for the experiment we are conducting, is not appropriate in financial time series, because it does not maintain the time ordering of the observations. The premise here is that while regime shifts may occur, there is some level of persistence of a given regime. . With this in mind, we are going to consider sequential resampling: . def calculate_resample_inds(N, n_groups): inds = np.arange(N) resample_inds = np.reshape(inds[0:n_groups*int(np.floor(N/n_groups))], (-1, n_groups)) return resample_inds . . And let&#39;s generate the samples: . n_groups = 10 dependence_coefs = np.linspace(0, 1, 20) mi_scores_mean = list() mi_scores_scale = list() # Resampling indices inds = calculate_resample_inds(N=100000, n_groups=n_groups) for coef in dependence_coefs: ### On mean # Full sample samples = generate_samples(N=100000, dependence_coef=coef, which_param=1) samples_cause = normalize(samples[0]) samples_effect = normalize(samples[1]) # Resampling vals = [calculate_mutual_information_score(X=samples_cause[inds[:,i]], Y=samples_effect[inds[:,i]], n_perm=50) for i in range(0, n_groups)] mi_scores_mean.append(vals) ### On scale # Full sample samples = generate_samples(N=100000, dependence_coef=coef, which_param=2) samples_cause = normalize(samples[0]) samples_effect = normalize(samples[1]) # Resampling vals = [calculate_mutual_information_score(X=samples_cause[inds[:,i]], Y=samples_effect[inds[:,i]], n_perm=50) for i in range(0, n_groups)] mi_scores_scale.append(vals) mi_scores_mean = np.array(mi_scores_mean) mi_scores_scale = np.array(mi_scores_scale) . . And now plotting the results: . fig, axes = plt.subplots(1, 2, figsize=(12, 4)) axes[0].boxplot(mi_scores_mean.T) axes[0].set_xticklabels(np.round(dependence_coefs,2), rotation=90) axes[0].set_xlabel(&quot;Dependence coeficient&quot;) axes[0].set_ylabel(&quot;Mutual information score&quot;) axes[0].set_title(&quot;Relation on the mean&quot;) axes[1].boxplot(mi_scores_scale.T) axes[1].set_xticklabels(np.round(dependence_coefs,2), rotation=90) axes[1].set_xlabel(&quot;Dependence coeficient&quot;) axes[1].set_ylabel(&quot;Mutual information score&quot;) axes[1].set_title(&quot;Relation on the scale&quot;) plt.show() . . This resampling partially quantifies sample fluctuations and inhomogeneities. However, while in this conducted experiment we can generate samples of arbitrary size, in real datasets we are limited by the possible small number of available observations. In this case, excessive resampling, especially sequential resampling like we&#39;re doing here may lead to completely useless information. . Conclusions . The idea behind this exposition was to demonstrate the strengths of mutual-information based feature selection. One big advantage is the fact we can infer relationships that are not captured by other feature selection techniques. In the context of trading, it is tremendously important to be able to predict not only the direction of the next price movement but also the volatility or uncertainty in this forecast. This can be done, for example, by developing full probabilistic regression models or, in the context of classifications models, using the meta-labeling technique, as described in (De Prado, 2018). Mutual information-based feature selection can then be used to construct these models. . References: . De Prado, M. L. (2018). Advances in financial machine learning. John Wiley &amp; Sons. | Cover, T. M. (1999). Elements of information theory. John Wiley &amp; Sons. | .",
            "url": "https://joaodmrodrigues.github.io/elements-financial-machine-learning/information%20theory/mutual%20information/feature%20selection/feature%20importance/2021/02/06/mutal_information_and_feature_selection.html",
            "relUrl": "/information%20theory/mutual%20information/feature%20selection/feature%20importance/2021/02/06/mutal_information_and_feature_selection.html",
            "date": " • Feb 6, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "I’m a data scientist and systematic trader on a personal account. . Brief resume: . 2021 - present: Data Scientist @ Argus Media, development of forecast models for commodity markets; . | 2019 - 2020: Research Associate @ Imperial College London, machine learning applications in physics; . | 2014 - 2018: PhD in Physics @ University of Lisbon, machine learning description of turbulence; . | . For more information check the links in the bottom of this page. .",
          "url": "https://joaodmrodrigues.github.io/elements-financial-machine-learning/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
      ,"page9": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://joaodmrodrigues.github.io/elements-financial-machine-learning/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

  
  

}